[⬅️ 上一页: go.mod文件参考](go.mod文件参考.md) 🚦 [下一页: 贡献指南 ➡️](贡献指南.md)

[返回上一级: 参考 ⬆️](../参考.md)

# Go内存模型

## 简介

Go内存模型规定，在一个goroutine中读取一个变量时，可以保证观察到不同goroutine中对同一变量的写入所产生的数值。

### 建议

修改被多个goroutine同时访问的数据的程序必须将这种访问序列化。

为了序列化访问，用通道操作或其他同步原语来保护数据，比如sync和sync/atomic包中的数据。

如果你必须阅读本文档的其余部分才能理解你的程序的行为，那么你就太聪明了。

不要自作聪明。

### 非正式的概述

Go 处理其内存模型的方式与语言的其他部分基本相同，目的是保持语义的简单、易懂和有用。本节给出了该方法的总体概述，对大多数程序员来说应该足够了。内存模型将在下一节中更正式地说明。

数据竞赛被定义为对一个内存位置的写与对同一位置的另一个读或写同时发生，除非所有涉及的访问都是由sync/atomic包提供的原子数据访问。如前所述，我们强烈建议程序员使用适当的同步来避免数据竞赛。在没有数据竞赛的情况下，Go程序的表现就像所有的goroutines都被复用到一个处理器上一样。这一特性有时被称为DRF-SC：无数据竞赛的程序以顺序一致的方式执行。

虽然程序员应该编写没有数据竞赛的Go程序，但Go实现对数据竞赛的反应是有限制的。一个实现可以通过报告竞赛并终止程序来应对数据竞赛。否则，每次读取单字大小或子字大小的内存位置时，必须观察到实际写入该位置的值（可能是由并发执行的goroutine写的），并且尚未被覆盖。这些执行约束使Go更像Java或JavaScript，因为大多数竞赛都有有限的结果，而不像C和C++，因为在C和C++中，任何有竞赛的程序的意义都是完全未定义的，编译器可以做任何事情。Go的方法旨在使错误的程序更可靠，更容易调试，同时仍然坚持认为竞赛是一种错误，工具可以诊断和报告它们。

## 内存模型

以下是Go的内存模型的正式定义，紧跟Hans-J. Boehm和Sarita V. Adve在“[Foundations of the C++ Concurrency Memory Model](https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf)”（发表于2008年PLDI）中提出的方法。无数据种族程序的定义和无种族程序的顺序一致性保证与该著作中的定义相当。

内存模型描述了对程序执行的要求，程序执行是由goroutine执行组成的，而goroutine又是由内存操作组成的。

一个内存操作由四个细节建模：
- 它的种类，表明它是一个普通的数据读取，一个普通的数据写入，还是一个同步操作，如一个原子数据访问，一个互斥操作，或一个通道操作。
- 它在程序中的位置。
- 被访问的内存位置或变量。
- 该操作所读取或写入的值。

一些内存操作是类似读的，包括读、原子读、互斥锁和通道接收。其他内存操作是类似写的，包括写、原子写、互斥解锁、通道发送和通道关闭。有些操作，例如原子比较和交换，既是读操作，又是写操作。

一个goroutine的执行被建模为由一个goroutine执行的一组内存操作。






[返回顶部 🔝](#Go内存模型)